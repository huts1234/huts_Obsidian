`万能头：# include <bits/stdc++.h>`
# 递归
## 一.  使用递归函数求解等比数列
	描述：输入一个整数n，求出等比数列2 4 8 16 32 ······的第n项的值。
	输入：一个整数n。
	输出：一个整数，等比数列的结果
	输入样例：6
	输出样例：64
  ``` c++
#include <iostream>  
using namespace std;  
int f(int n) {  
    int res ;  
    if (n == 1) { res = 2;}  
    else{ res = f(n-1) * 2;}  
    return res;  
}  
int main() {  
    cout << f(6) << endl;  
    return 0;  
}
  ```



## 二.  使用递归函数求解阶乘
	描述：输入一个整数n，求出n的阶乘结果。
	输入：一个整数n
	输出：一个整数，n！的结果
	输入样例：5
	输出样例：120

``` C++
#include <iostream>  
using namespace std;  
int f(int n) {  
    int res ;  
    if (n == 1) { res = 1;}  
    else{ res = f(n-1) *n;}  
    return res;  
}  
int main() {  
    cout << f(5) << endl;  
    return 0;  
}
```


## 三.  兔子问题
开始只有一对兔子，从出生之后的第3个月起，每个月都生出一对兔子，一对兔子成长到第三个月后每个月又生一对兔子，假如兔子都不死，问第n个月（你<=50）的兔子总数是多少对？

| 月份n | 兔子                            | 兔子对数 |
| --- | ----------------------------- | ---- |
| 1   | a1 a2                         | 1    |
| 2   | a1 a2                         | 1    |
| 3   | a1 a2 b1 b2                   | 2    |
| 4   | a1 a2 b1 b2 c1 c2             | 3    |
| 5   | a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 | 5    |
| 6   |                               | 8    |
| 7   |                               | 13   |
| 8   |                               | 21   |
| 9   |                               | 34   |
| 10  |                               | 55   |
|     |                               |      |
第n月的兔子对数=第（n-1）月的兔子对数+第（n-1）月的兔子对数


### 方法一：

``` c++

#include <iostream>  
using namespace std;  
int f(int n) {  
    int res ;  
    if (n == 1 || n == 2) { res = 1;}  
    else{ res = f(n-1) + f(n-2);}  
    return res;  
}  
int main() {  
    int n;  
    cin >> n;  
    cout << f(n) << endl;  
    return 0;  
}

```

### 方法二：

``` C++
#include <iostream>  
using namespace std;  
  
int main() {  
    long long a[60];  
    a[1]=1;  
    a[2]=1;  
    for(int i=3;i<=50;i++)  
    {  
        a[i] = a[i-1] + a[i-2];  
    }  
  
   for(int i=0;i<=50;i++)  
   {  
       cout << i <<":" <<a[i] << endl;  
   }  
    return 0;  
}
```
# 递推
## 一.  
	在墙角按照规律堆放着一些完全相同的正方体小块儿，只需要知道层数就可以计算出所有小块的数量。
	输入：一个整数你（1<=n<=100）,代表层数。
	输出：一个整数，表示这堆小块儿的总量。


| 层数n(1<=n<=100) | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| -------------- | --- | --- | --- | --- | --- | --- | --- |
| 小块儿本层个数x       | 1   | 3   | 6   | 10  | 15  | 21  | 28  |
| 小块儿的总量s        | 1   | 4   | 10  | 20  | 35  | 56  | 84  |
``小块儿本层个数=小块的层数+小块上一层的个数   
``小块儿的总量=小块儿本层个数+上一层数时的小块儿总量
 `` A(n) = A(n-1) + n


``` C++
#include <iostream>  
using namespace std;  
  
int main() {  
    int n;  
    cin >> n;  
  
    int level = 1;  
  
    int sum = 1;  
  
    for (int i = 2; i <= n; i++) {  
        level = level + i;  
        sum += level;  
  
  
    }  
    cout << sum;  
  
    return 0;  
}
```
## 二.  猴子吃桃
	描述：猴子摘下一堆桃子，第一天吃了一半之后多吃了一个；
	第二天同样多吃了一半多一个，之后每天如此，
	到第十天只剩下一个桃子，
	问：第一天摘了多少？
	输入：无
	输出：一个整数，表示第一天摘了多少个桃子
``` C++


```

## 三.  求解一个有规律式子的前n项
	描述：求1/1+1/2+2/3+3/5+5/8+8/13+13/21···的前n项的和。
	输入：一个整数n（1<=n<=30）
	输出：一个小数，代表前n项的和（保留3位小数）
	输入样例：20
	输出样例：12.660
```  C++


```
## 四.  过河卒
A点有一个过河卒  需要走到目标B点。它只能向下或者向右移动，在棋盘中的任意一个点上有对方的马，记为C点。
马所在的点和所有跳跃一步可达的点称为对方马的控制点。
请计算出小卒从A点能够顺利抵达B点的路径条数。

|     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | ……  | m      |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------ |
| 0   | A   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |     |        |
| 1   | 1   | 2   | 3   |     |     |     |     |     |     |     |        |
| 2   | 1   | 3   |     |     |     |     |     |     |     |     |        |
| 3   | 1   |     |     |     |     |     |     |     |     |     |        |
| 4   | 1   |     |     |     |     |     |     |     |     |     |        |
| ……  |     |     |     |     |     |     |     |     |     |     |        |
| n   |     |     |     |     |     |     |     |     |     |     | B(n,m) |

- 输入：B点的坐标（m，n）以及对方马C的坐标（x，y） （马的坐标一定在棋盘范围内，但可能落在边界上）（m，n<=20）
- 小卒从A点到B点的路径条数
- 输入样例：6  6  3  2
- 输出样例：17
`马所在的点为A点（0，0）`
1. 不考虑马的情况
``` C++

#include <iostream>  
using namespace std;  
  
int main() {  
   int a[30][30] = {0}; // 创建二维数组表示整个棋盘  
    int n , m ; // 输入 n,m。 分别表示目标B点的行和列  
    cin >> n >> m;  
  
    // 遍历整个从A到B的二维数组  
    for (int i = 0; i <= n; i++) // 从第0行开始遍历，到B点所在的行，即n行，因此包含n  
        {  
        for (int j = 0; j <= m; j++) //遍历二维数组所有的列  
            {  
            if (i == 0 && j == 0)  // 如果B点的位置和A点重合，则不需要计算  
                {  
                continue;  
            }  
            if (i == 0 || j == 0) {  
                a[i][j] = 1;  
            }  
            else {  
                a[i][j] = a[i - 1][j] + a[i][j - 1] ;  
            }  
        }  
    }  
    cout << a[n][m];  
    return 0;  
}

```

2. 考虑马的情况
``` C++
#include <bits/stdc++.h>  
using namespace std;  
  
int main() {  
   int a[30][30] = {0}; // 创建二维数组表示整个棋盘  
    int n , m ,x,y; // 输入 n,m。 分别表示目标B点的行和列  
    cin >> n >> m >> x >> y;  
  
  
    for (int i = 0; i <= n; i++)  
        {  
        for (int j = 0; j <= m; j++){  
                a[i][j] = 1;  
        }  
    }  
    a[x][y] = 0;  
    if (x+2<=n && y-1>=0) { a[x+2][y-1] = 0; }  
    if (x+2<=n && y+1<=m) { a[x+2][y+1] = 0; }  
    if (x+1<=n && y+2<=m) { a[x+1][y+2] = 0; }  
    if (x-1>=0 && y+2<=m) { a[x-1][y+2] = 0; }  
    if (x-2>=0 && y+1<=m) { a[x-2][y+1] = 0; }  
    if (x-2>=0 && y-1>=0) { a[x-2][y-1] = 0; }  
    if (x-1>=0 && y-2>=0) { a[x-1][y-2] = 0; }  
    if (x+1<=m && y-2>=0) { a[x+1][y-2] = 0; }  
    for (int i = 0; i <= n; i++) // 从第0行开始遍历，到B点所在的行，即n行，因此包含n  
        {  
        for (int j = 0; j <= m; j++)  // 遍历二维数组所在的列  
            {  
            if (i == 0 && j == 0) {  
                continue;  
            }  
            if (a[i][j] == 0) {  
                continue;  
            }  
            if (i == 0) {  
                a[i][j] = a[i][j-1];  
            }  
            else if (j == 0 ) {  
                a[i][j] = a[i-1][j];  
            }  
            else {  
                a[i][j] = a[i-1][j] + a[i][j-1];  
            }  
        }  
    }  
    cout << a[n][m];  
    return 0;  
}
```

## 五.  棋盘数量
	描述：设有一个N*M方格的棋盘（1<=N<=100,1<=M<=100）
	求出该棋盘中包含有多少个正方形，多少个长方形（不包括正方形）。
	

|     |     |     |
| --- | --- | --- |
|     |     |     |
	例如： 当N= 2，M  = 3时：正方形的个数有8个，
		   即边长为1的正方形有6个：边长为2的正放形有2个。
		   长方形的个数有10个
	输入：N，M
	输出：正方形个数与长方形个数
	样例输出：2 3
	样例输出： 8 10
``` C++

```

# 贪心
## 一.  排队打水
题目：有n个人排队到r个水龙头前去打水，他们装满水桶的时间分别为t1,t2,t3,……，tn，打水时间均为整数且个不相等，应该如何安排他们的打水顺序才能